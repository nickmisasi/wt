#!/bin/bash

set -e

#
# Git Worktree Manager
#
# This script creates git worktrees for both server and enterprise repositories
# in a new base directory structure, and copies all base files.
#
# For tab completion, source the completion script:
#   source ./worktree-completion.bash
#
# Configuration - change these if your directories have different names

SERVER_DIR_NAME="server"
ENTERPRISE_DIR_NAME="enterprise"

# List of additional files to copy to server worktree
server_files=(
    "webapp/.dir-locals.el:webapp/.dir-locals.el"
    "config/config.json:config/config.json"
    "docker-compose.override.yaml:docker-compose.override.yaml"
    "server/config.override.mk:server/config.override.mk"
    # Add more files here in format "source:destination"
    # "sub-dir/other-file.txt:sub-dir/other-file.txt"
)

# List of additional files to copy to enterprise worktree
enterprise_files=(
    # Add files here in format "source:destination"
    # "sub-dir/other-file.txt:sub-dir/other-file.txt"
)



# Get current directory name to use as base name
BASENAME=$(basename "$(pwd)")

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to detect the default branch (master for this repo)
detect_default_branch() {
    local repo_dir="$1"
    local default_branch=""
    
    # Check if we're in a git repo
    if [ ! -d "$repo_dir/.git" ]; then
        echo "master"  # fallback default
        return
    fi
    
    # Try to get default branch from remote
    default_branch=$(cd "$repo_dir" 2>/dev/null && git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
    
    if [ -n "$default_branch" ]; then
        echo "$default_branch"
        return
    fi
    
    # Always default to master for this repo
    echo "master"
}

# Function to get all available branches for base branch selection
get_all_branches() {
    local repo_dir="$1"
    if [ -d "$repo_dir/.git" ]; then
        (cd "$repo_dir" 2>/dev/null && {
            git branch --format='%(refname:short)' 2>/dev/null
            git branch -r --format='%(refname:short)' 2>/dev/null | sed 's|origin/||' | grep -v HEAD
        } | sort -u 2>/dev/null)
    fi
}

# Function to prompt for server port
prompt_for_server_port() {
    local default_port="8065"
    local selected_port=""

    echo "" >&2
    print_status "What port should the Mattermost server use?" >&2
    echo -n "Enter port number (default: $default_port): " >&2
    read selected_port

    # If empty, use default
    if [ -z "$selected_port" ]; then
        selected_port="$default_port"
    fi

    # Validate port number
    if ! [[ "$selected_port" =~ ^[0-9]+$ ]] || [ "$selected_port" -lt 1 ] || [ "$selected_port" -gt 65535 ]; then
        print_error "Invalid port number. Using default: $default_port" >&2
        selected_port="$default_port"
    fi

    printf "%s" "$selected_port"
}

# Function to prompt for metrics port
prompt_for_metrics_port() {
    local default_port="8067"
    local selected_port=""

    echo "" >&2
    print_status "What port should the Mattermost metrics server use?" >&2
    echo -n "Enter metrics port number (default: $default_port): " >&2
    read selected_port

    # If empty, use default
    if [ -z "$selected_port" ]; then
        selected_port="$default_port"
    fi

    # Validate port number
    if ! [[ "$selected_port" =~ ^[0-9]+$ ]] || [ "$selected_port" -lt 1 ] || [ "$selected_port" -gt 65535 ]; then
        print_error "Invalid port number. Using default: $default_port" >&2
        selected_port="$default_port"
    fi

    printf "%s" "$selected_port"
}

# Function to update server port in config.json
update_server_port() {
    local config_file="$1"
    local port="$2"
    local metrics_port="$3"

    if [ ! -f "$config_file" ]; then
        print_warning "Config file not found: $config_file"
        return 1
    fi

    print_status "Updating server port to $port and metrics port to $metrics_port in config.json"

    # Update ListenAddress, SiteURL, and MetricsSettings.ListenAddress
    if command -v sed >/dev/null 2>&1; then
        # macOS/BSD sed requires -i with an argument (empty string for no backup)
        if sed --version >/dev/null 2>&1; then
            # GNU sed
            # Update ServiceSettings.ListenAddress (first occurrence)
            sed -i "0,/\"ListenAddress\": \":[0-9]*\"/s//\"ListenAddress\": \":$port\"/" "$config_file"
            # Update SiteURL
            sed -i "s|\"SiteURL\": \"http://localhost:[0-9]*\"|\"SiteURL\": \"http://localhost:$port\"|" "$config_file"
            # Update MetricsSettings.ListenAddress (second occurrence, within MetricsSettings section)
            sed -i "/\"MetricsSettings\":/,/}/{s/\"ListenAddress\": \":[0-9]*\"/\"ListenAddress\": \":$metrics_port\"/}" "$config_file"
        else
            # BSD/macOS sed
            # Update ServiceSettings.ListenAddress (first occurrence)
            sed -i '' "1,/\"ListenAddress\": \":[0-9]*\"/{s/\"ListenAddress\": \":[0-9]*\"/\"ListenAddress\": \":$port\"/;}" "$config_file"
            # Update SiteURL
            sed -i '' "s|\"SiteURL\": \"http://localhost:[0-9]*\"|\"SiteURL\": \"http://localhost:$port\"|" "$config_file"
            # Update MetricsSettings.ListenAddress
            sed -i '' "/\"MetricsSettings\":/,/}/{s/\"ListenAddress\": \":[0-9]*\"/\"ListenAddress\": \":$metrics_port\"/;}" "$config_file"
        fi
        print_status "Updated server ListenAddress to :$port, SiteURL to http://localhost:$port, and metrics ListenAddress to :$metrics_port"
    else
        print_error "sed command not found. Cannot update config.json"
        return 1
    fi
}

# Function to prompt for base branch with completion support
prompt_for_base_branch() {
    local repo_dir="$1"
    local default_branch=$(detect_default_branch "$repo_dir")
    local selected_branch=""

    print_status "Branch $BRANCH_NAME does not exist in $repo_dir. What branch should be used as base?" >&2
    echo "Available branches:" >&2
    get_all_branches "$repo_dir" | sed 's/^/  /' >&2
    echo "" >&2
    
    # Enable bash completion for the read command if available
    if [ -n "$BASH_VERSION" ]; then
        # Set up completion for branch names
        local branches=$(get_all_branches "$repo_dir" | tr '\n' ' ')
        
        # Create a completion function for this specific read
        _branch_complete() {
            local cur="${COMP_WORDS[COMP_CWORD]}"
            COMPREPLY=($(compgen -W "$branches" -- "$cur"))
        }
        
        # Temporarily set up completion
        complete -F _branch_complete read
        
        # Use readline with completion (without -i for macOS compatibility)
        echo -n "Enter base branch (default: $default_branch): " >&2
        read -e selected_branch
        
        # Remove temporary completion
        complete -r read 2>/dev/null || true
        
        # If empty, use default
        if [ -z "$selected_branch" ]; then
            selected_branch="$default_branch"
        fi
    else
        # Fallback for non-bash shells
        echo -n "Enter base branch (default: $default_branch): " >&2
        read selected_branch
        
        # If empty, use default
        if [ -z "$selected_branch" ]; then
            selected_branch="$default_branch"
        fi
    fi
    
    printf "%s" "$selected_branch"
}

# Function to show usage
usage() {
    echo "Usage: $0 <command> [arguments]"
    echo ""
    echo "Commands:"
    echo "  create <branch-name> <short-name>  Create worktrees for branch with short directory name"
    echo "  remove <branch-name> [--force]     Remove worktrees and worktree base directory"
    echo "  list                               List existing worktree directories"
    echo ""
    echo "Examples:"
    echo "  $0 create MM-63556-compliance-export-download compliance-export"
    echo "  $0 remove MM-63556-compliance-export-download"
    echo "  $0 remove MM-63556-compliance-export-download --force"
    echo "  $0 list"
    echo ""
    echo "Create will make:"
    echo "  - $BASENAME-compliance-export/"
    echo "    ├── CLAUDE.md, CLAUDE.local.md, etc. (copied from current base dir)"
    echo "    ├── $SERVER_DIR_NAME/ (git worktree for MM-63556-compliance-export-download branch)"
    echo "    └── $ENTERPRISE_DIR_NAME/ (git worktree for MM-63556-compliance-export-download branch)"
    exit 1
}

# Check for help flags
if [ "$1" = "--help" ] || [ "$1" = "-h" ] || [ "$1" = "help" ]; then
    usage
fi

# Parse command and arguments
if [ $# -eq 0 ]; then
    print_error "Command is required"
    usage
fi

COMMAND="$1"
BRANCH_NAME=""
SERVER_PORT="8065"    # Default server port
METRICS_PORT="8067"  # Default metrics port

# Validate command
if [ "$COMMAND" != "create" ] && [ "$COMMAND" != "remove" ] && [ "$COMMAND" != "list" ]; then
    print_error "Invalid command: $COMMAND"
    print_error "Valid commands: create, remove, list"
    usage
fi

# Check arguments for commands
FORCE_MODE=false
BRANCH_NAME=""
SHORT_NAME=""

if [ "$COMMAND" = "create" ]; then
    # Create command needs: create <branch-name> <short-name>
    if [ $# -ne 3 ]; then
        print_error "Create command requires both branch-name and short-name"
        print_error "Usage: $0 create <branch-name> <short-name>"
        usage
    fi
    BRANCH_NAME="$2"
    SHORT_NAME="$3"
elif [ "$COMMAND" = "remove" ]; then
    # Remove command: remove <branch-name> [--force]
    if [ $# -eq 3 ] && [ "$3" = "--force" ]; then
        FORCE_MODE=true
        BRANCH_NAME="$2"
    elif [ $# -eq 3 ] && [ "$2" = "--force" ]; then
        FORCE_MODE=true  
        BRANCH_NAME="$3"
    elif [ $# -eq 2 ]; then
        BRANCH_NAME="$2"
    else
        print_error "Remove command requires branch-name"
        print_error "Usage: $0 remove <branch-name> [--force]"
        usage
    fi
elif [ "$COMMAND" = "list" ]; then
    # List command takes no additional arguments
    if [ $# -ne 1 ]; then
        print_error "List command takes no arguments"
        usage
    fi
fi

# Validate names for create/remove commands
if [ "$COMMAND" = "create" ]; then
    if [[ ! "$BRANCH_NAME" =~ ^[a-zA-Z0-9_\.-]+$ ]]; then
        print_error "Invalid branch name. Use only letters, numbers, hyphens, periods, and underscores."
        exit 1
    fi
    if [[ ! "$SHORT_NAME" =~ ^[a-zA-Z0-9_\.-]+$ ]]; then
        print_error "Invalid short name. Use only letters, numbers, hyphens, periods, and underscores."
        exit 1
    fi
elif [ "$COMMAND" = "remove" ]; then
    if [[ ! "$BRANCH_NAME" =~ ^[a-zA-Z0-9_\.-]+$ ]]; then
        print_error "Invalid branch name. Use only letters, numbers, hyphens, periods, and underscores."
        exit 1
    fi
fi

# Function to list existing worktree directories
list_worktrees() {
    local parent_dir=$(dirname "$CURRENT_DIR")
    local found=false
    
    print_status "Existing worktree directories:"
    for dir in "$parent_dir"/$BASENAME-*; do
        if [ -d "$dir" ]; then
            local short_name=$(basename "$dir" | sed "s/^$BASENAME-//")
            local branch_info=""
            
            # Try to get branch info from server worktree
            if [ -d "$dir/$SERVER_DIR_NAME" ]; then
                branch_info=$(cd "$dir/$SERVER_DIR_NAME" 2>/dev/null && git branch --show-current 2>/dev/null)
                if [ -n "$branch_info" ]; then
                    echo "  - $short_name (branch: $branch_info)"
                else
                    echo "  - $short_name (branch: unknown)"
                fi
            else
                echo "  - $short_name (invalid - no $SERVER_DIR_NAME directory)"
            fi
            found=true
        fi
    done
    
    if [ "$found" = false ]; then
        echo "  No worktree directories found"
    fi
}

# Function to remove worktrees and base directory
remove_worktree() {
    local branch_name="$1"
    local force_mode="$2"
    local parent_dir=$(dirname "$CURRENT_DIR")
    local base_dir=""
    local server_worktree=""
    local enterprise_worktree=""
    
    print_status "Searching for worktrees with branch: $branch_name"

    # Find the base directory that contains this branch
    local found=false
    local match_type=""

    # First, try to match by git branch name
    for dir in "$parent_dir"/$BASENAME-*; do
        if [ -d "$dir/$SERVER_DIR_NAME" ]; then
            local current_branch=$(cd "$dir/$SERVER_DIR_NAME" 2>/dev/null && git branch --show-current 2>/dev/null)
            if [ "$current_branch" = "$branch_name" ]; then
                base_dir="$dir"
                server_worktree="$dir/$SERVER_DIR_NAME"
                enterprise_worktree="$dir/$ENTERPRISE_DIR_NAME"
                found=true
                match_type="branch"
                break
            fi
        fi
    done

    # If not found by branch name, try to match by short name (directory suffix)
    if [ "$found" = false ]; then
        local target_dir="$parent_dir/$BASENAME-$branch_name"
        if [ -d "$target_dir/$SERVER_DIR_NAME" ]; then
            base_dir="$target_dir"
            server_worktree="$target_dir/$SERVER_DIR_NAME"
            enterprise_worktree="$target_dir/$ENTERPRISE_DIR_NAME"
            found=true
            match_type="short-name"
        fi
    fi

    if [ "$found" = false ]; then
        print_error "No worktree found for branch or short name: $branch_name"
        exit 1
    fi

    if [ "$match_type" = "branch" ]; then
        print_status "Found worktree by branch name: $branch_name"
    else
        print_status "Found worktree by short name: $branch_name"
    fi
    
    print_status "Found base directory: $base_dir"
    
    # Show what will be removed
    echo ""
    print_warning "This will remove the following:"
    echo "  - Git worktree: $server_worktree"
    echo "  - Git worktree: $enterprise_worktree" 
    echo "  - Entire directory: $base_dir"
    echo ""
    
    # Confirmation prompt (unless force mode)
    if [ "$force_mode" = false ]; then
        print_warning "Are you sure you want to remove these worktrees and directory? [y/N]"
        read -r response
        
        case "$response" in
            [yY]|[yY][eE][sS])
                print_status "Proceeding with removal..."
                ;;
            *)
                print_status "Removal cancelled."
                exit 0
                ;;
        esac
    else
        print_status "Force mode enabled - skipping confirmation."
    fi
    
    # Remove server worktree
    if [ -d "$server_worktree" ]; then
        print_status "Removing server worktree: $server_worktree"
        (cd "$SERVER_DIR_NAME" && git worktree remove --force "$server_worktree" || true)
    fi
    
    # Remove enterprise worktree
    if [ -d "$enterprise_worktree" ]; then
        print_status "Removing enterprise worktree: $enterprise_worktree"
        (cd "$ENTERPRISE_DIR_NAME" && git worktree remove --force "$enterprise_worktree" || true)
    fi
    
    # Remove the entire base directory
    print_status "Removing base directory: $base_dir"
    rm -rf "$base_dir"
    
    print_status "Successfully removed worktrees and directory for branch: $branch_name"
    
    # Ask if user wants to delete the branches from both repos (unless force mode)
    if [ "$force_mode" = false ]; then
        echo ""
        echo -e "${RED}[WARNING]${NC} Do you also want to delete the branch '$branch_name' from both server and enterprise repositories?"
        echo -e "${RED}[WARNING]${NC} This will permanently delete the branch and cannot be undone!"
        echo -e "${RED}[WARNING]${NC} Only do this if you're sure you no longer need the branch."
        echo ""
        echo -e "${YELLOW}Delete branches from repositories? [y/N]${NC}"
        read -r delete_branches_response
        
        case "$delete_branches_response" in
            [yY]|[yY][eE][sS])
                print_status "Deleting branch '$branch_name' from repositories..."
                
                # Delete from server repo
                if (cd "$SERVER_DIR_NAME" 2>/dev/null && git show-ref --verify --quiet "refs/heads/$branch_name"); then
                    print_status "Deleting branch '$branch_name' from $SERVER_DIR_NAME repository"
                    (cd "$SERVER_DIR_NAME" && git branch -D "$branch_name" 2>/dev/null || true)
                fi
                
                # Delete from enterprise repo
                if (cd "$ENTERPRISE_DIR_NAME" 2>/dev/null && git show-ref --verify --quiet "refs/heads/$branch_name"); then
                    print_status "Deleting branch '$branch_name' from $ENTERPRISE_DIR_NAME repository"
                    (cd "$ENTERPRISE_DIR_NAME" && git branch -D "$branch_name" 2>/dev/null || true)
                fi
                
                print_status "Branch deletion completed"
                ;;
            *)
                print_status "Branch deletion skipped - branches remain in repositories"
                ;;
        esac
    else
        print_status "Force mode enabled - skipping branch deletion prompt"
    fi
}

# Get current directory and validate structure
CURRENT_DIR=$(pwd)
CURRENT_BASENAME=$(basename "$CURRENT_DIR")

# Validate that server and enterprise directories exist and are git repos
if [ ! -d "$SERVER_DIR_NAME" ]; then
    print_error "$SERVER_DIR_NAME directory not found in current directory"
    exit 1
fi

if [ ! -d "$ENTERPRISE_DIR_NAME" ]; then
    print_error "$ENTERPRISE_DIR_NAME directory not found in current directory"
    exit 1
fi

if [ ! -d "$SERVER_DIR_NAME/.git" ]; then
    print_error "$SERVER_DIR_NAME directory is not a git repository"
    exit 1
fi

if [ ! -d "$ENTERPRISE_DIR_NAME/.git" ]; then
    print_error "$ENTERPRISE_DIR_NAME directory is not a git repository"
    exit 1
fi

# Command dispatcher
case "$COMMAND" in
    "list")
        list_worktrees
        exit 0
        ;;
    "remove")
        remove_worktree "$BRANCH_NAME" "$FORCE_MODE"
        exit 0
        ;;
    "create")
        # Continue with create logic below
        ;;
    *)
        print_error "Unknown command: $COMMAND"
        usage
        ;;
esac

# Create command logic starts here
# Get parent directory (where we'll create the new base directory)
PARENT_DIR=$(dirname "$CURRENT_DIR")
NEW_BASE_DIR="$PARENT_DIR/$BASENAME-$SHORT_NAME"
SERVER_WORKTREE_DIR="$NEW_BASE_DIR/$SERVER_DIR_NAME"
ENTERPRISE_WORKTREE_DIR="$NEW_BASE_DIR/$ENTERPRISE_DIR_NAME"

# Initialize BASE_BRANCH variable (may be set later if branch doesn't exist)
BASE_BRANCH=""

print_status "Branch name: $BRANCH_NAME"
print_status "Short name: $SHORT_NAME"
print_status "New base directory: $NEW_BASE_DIR"
print_status "Server worktree: $SERVER_WORKTREE_DIR"
print_status "Enterprise worktree: $ENTERPRISE_WORKTREE_DIR"

# Check if new base directory already exists
if [ -d "$NEW_BASE_DIR" ]; then
    print_error "Directory already exists: $NEW_BASE_DIR"
    exit 1
fi

# Create the new base directory
print_status "Creating new base directory: $NEW_BASE_DIR"
mkdir -p "$NEW_BASE_DIR"

# Function to cleanup on error
cleanup() {
    print_error "Cleaning up due to error..."
    if [ -d "$NEW_BASE_DIR" ]; then
        rm -rf "$NEW_BASE_DIR"
        print_status "Cleaned up: $NEW_BASE_DIR"
    fi
    cd "$CURRENT_DIR"
    cd "$SERVER_DIR_NAME"
    git worktree prune
    cd "$CURRENT_DIR"
    cd "$ENTERPRISE_DIR_NAME"
    git worktree prune
}

# Set trap for cleanup on error
trap cleanup ERR

# Copy all files and directories from current base dir (except server and enterprise)
print_status "Copying base files (excluding server and enterprise directories)..."
for item in * .*; do
    # Skip . and .. and server and enterprise directories
    if [ "$item" = "." ] || [ "$item" = ".." ] || [ "$item" = "$SERVER_DIR_NAME" ] || [ "$item" = "$ENTERPRISE_DIR_NAME" ]; then
        continue
    fi
    
    # Skip if item doesn't exist (handles glob expansion issues)
    if [ ! -e "$item" ]; then
        continue
    fi
    
    print_status "Copying: $item"
    cp -r "$item" "$NEW_BASE_DIR/"
done

# Check if branch exists in server repo
print_status "Checking $SERVER_DIR_NAME repository for branch: $BRANCH_NAME"
cd "$SERVER_DIR_NAME"

SERVER_BRANCH_EXISTS=false
if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
    print_status "Branch $BRANCH_NAME exists locally in $SERVER_DIR_NAME"
    SERVER_BRANCH_EXISTS=true
elif git show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME"; then
    print_status "Branch $BRANCH_NAME exists on remote in $SERVER_DIR_NAME"
    SERVER_BRANCH_EXISTS=true
else
    print_status "Branch $BRANCH_NAME does not exist in $SERVER_DIR_NAME - will create new branch"
fi

# Create server worktree
print_status "Creating server worktree: $SERVER_WORKTREE_DIR"
if [ "$SERVER_BRANCH_EXISTS" = true ]; then
    # Branch exists - check it out
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        # Branch exists locally
        git worktree add "$SERVER_WORKTREE_DIR" "$BRANCH_NAME"
    elif git show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME"; then
        # Branch exists on remote - track it
        git worktree add --track -b "$BRANCH_NAME" "$SERVER_WORKTREE_DIR" "origin/$BRANCH_NAME"
    fi
else
    # Branch doesn't exist - create it from base
    BASE_BRANCH=$(prompt_for_base_branch "$SERVER_DIR_NAME")
    print_status "Using base branch: $BASE_BRANCH"

    # Validate that base branch exists
    if ! git show-ref --verify --quiet "refs/heads/$BASE_BRANCH" && ! git show-ref --verify --quiet "refs/remotes/origin/$BASE_BRANCH"; then
        print_error "Base branch $BASE_BRANCH does not exist"
        cd "$CURRENT_DIR"
        cleanup
        exit 1
    fi

    if git show-ref --verify --quiet "refs/heads/$BASE_BRANCH"; then
        # Base branch exists locally
        git worktree add -b "$BRANCH_NAME" "$SERVER_WORKTREE_DIR" "$BASE_BRANCH"
    elif git show-ref --verify --quiet "refs/remotes/origin/$BASE_BRANCH"; then
        # Base branch exists on remote
        git worktree add -b "$BRANCH_NAME" "$SERVER_WORKTREE_DIR" "origin/$BASE_BRANCH"
    fi
fi

# Go back to base directory
cd "$CURRENT_DIR"

# Check if branch exists in enterprise repo
print_status "Checking $ENTERPRISE_DIR_NAME repository for branch: $BRANCH_NAME"
cd "$ENTERPRISE_DIR_NAME"

ENTERPRISE_BRANCH_EXISTS=false
if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
    print_status "Branch $BRANCH_NAME exists locally in $ENTERPRISE_DIR_NAME"
    ENTERPRISE_BRANCH_EXISTS=true
elif git show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME"; then
    print_status "Branch $BRANCH_NAME exists on remote in $ENTERPRISE_DIR_NAME"
    ENTERPRISE_BRANCH_EXISTS=true
else
    print_status "Branch $BRANCH_NAME does not exist in $ENTERPRISE_DIR_NAME - will create new branch"
fi

# Create enterprise worktree
print_status "Creating enterprise worktree: $ENTERPRISE_WORKTREE_DIR"
if [ "$ENTERPRISE_BRANCH_EXISTS" = true ]; then
    # Branch exists - check it out
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        # Branch exists locally
        git worktree add "$ENTERPRISE_WORKTREE_DIR" "$BRANCH_NAME"
    elif git show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME"; then
        # Branch exists on remote - track it
        git worktree add --track -b "$BRANCH_NAME" "$ENTERPRISE_WORKTREE_DIR" "origin/$BRANCH_NAME"
    fi
else
    # Branch doesn't exist - create it from base
    # Use the same BASE_BRANCH if it was already determined for server, otherwise prompt
    if [ -z "$BASE_BRANCH" ]; then
        BASE_BRANCH=$(prompt_for_base_branch "$ENTERPRISE_DIR_NAME")
        print_status "Using base branch: $BASE_BRANCH"
    else
        print_status "Using same base branch as server: $BASE_BRANCH"
    fi

    # Validate that base branch exists
    if ! git show-ref --verify --quiet "refs/heads/$BASE_BRANCH" && ! git show-ref --verify --quiet "refs/remotes/origin/$BASE_BRANCH"; then
        print_error "Base branch $BASE_BRANCH does not exist in $ENTERPRISE_DIR_NAME"
        cd "$CURRENT_DIR"
        cleanup
        exit 1
    fi

    if git show-ref --verify --quiet "refs/heads/$BASE_BRANCH"; then
        # Base branch exists locally
        git worktree add -b "$BRANCH_NAME" "$ENTERPRISE_WORKTREE_DIR" "$BASE_BRANCH"
    elif git show-ref --verify --quiet "refs/remotes/origin/$BASE_BRANCH"; then
        # Base branch exists on remote
        git worktree add -b "$BRANCH_NAME" "$ENTERPRISE_WORKTREE_DIR" "origin/$BASE_BRANCH"
    fi
fi

# Go back to base directory
cd "$CURRENT_DIR"

# Copy go work files
print_status "Copying go.work files and others..."
# Copy go.work* from $SERVER_DIR_NAME/servre to new $SERVER_DIR_NAME/server
for gowork_file in "$SERVER_DIR_NAME/server"/go.work*; do
    if [ -f "$gowork_file" ]; then
        print_status "Copying $(basename "$gowork_file") from $SERVER_DIR_NAME/server to new $SERVER_DIR_NAME/server"
        mkdir -p "$SERVER_WORKTREE_DIR/server"
        cp "$gowork_file" "$SERVER_WORKTREE_DIR/server/"
    fi
done

for file_mapping in "${server_files[@]}"; do
    source_file="$SERVER_DIR_NAME/${file_mapping%%:*}"
    dest_file="${file_mapping##*:}"
    
    if [ -f "$source_file" ]; then
        print_status "Copying $(basename "$source_file") to server worktree"
        mkdir -p "$(dirname "$SERVER_WORKTREE_DIR/$dest_file")"
        cp "$source_file" "$SERVER_WORKTREE_DIR/$dest_file"
    fi
done

# Copy go.work* from $ENTERPRISE_DIR_NAME to new $ENTERPRISE_DIR_NAME
for gowork_file in "$ENTERPRISE_DIR_NAME"/go.work*; do
    if [ -f "$gowork_file" ]; then
        print_status "Copying $(basename "$gowork_file") from $ENTERPRISE_DIR_NAME to new $ENTERPRISE_DIR_NAME"
        cp "$gowork_file" "$ENTERPRISE_WORKTREE_DIR/"
    fi
done

for file_mapping in "${enterprise_files[@]}"; do
    source_file="$ENTERPRISE_DIR_NAME/${file_mapping%%:*}"
    dest_file="${file_mapping##*:}"

    if [ -f "$source_file" ]; then
        print_status "Copying $(basename "$source_file") to enterprise worktree"
        mkdir -p "$(dirname "$ENTERPRISE_WORKTREE_DIR/$dest_file")"
        cp "$source_file" "$ENTERPRISE_WORKTREE_DIR/$dest_file"
    fi
done

# Prompt for and configure server port
SERVER_PORT=$(prompt_for_server_port)
METRICS_PORT=$(prompt_for_metrics_port)
print_status "Configuring server to use port $SERVER_PORT and metrics port $METRICS_PORT"

# Update config.json if it exists
CONFIG_FILE="$SERVER_WORKTREE_DIR/config/config.json"
if [ -f "$CONFIG_FILE" ]; then
    update_server_port "$CONFIG_FILE" "$SERVER_PORT" "$METRICS_PORT"
else
    print_warning "config.json not found at $CONFIG_FILE - you may need to configure the ports manually"
fi

# Remove trap since we succeeded
trap - ERR

print_status "Successfully created worktrees and copied base files!"
echo ""
print_status "Directory structure:"
echo "  $NEW_BASE_DIR/"
echo "  ├── CLAUDE.md, CLAUDE.local.md, mise.toml, etc. (copied files)"
echo "  ├── $(basename "$SERVER_WORKTREE_DIR")/ (git worktree)"
echo "  └── $(basename "$ENTERPRISE_WORKTREE_DIR")/ (git worktree)"
echo ""
print_status "Server configured to run on:"
echo "  - Main server port: $SERVER_PORT"
echo "  - Metrics port:     $METRICS_PORT"
print_status "Access the server at: http://localhost:$SERVER_PORT"
print_status "Access metrics at:    http://localhost:$METRICS_PORT/metrics"
echo ""
print_status "To remove these worktrees later, use:"
echo "  ./worktree remove $BRANCH_NAME"
